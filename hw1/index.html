<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2026 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: Patrick (Tsung-Han) Wu</div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-tsunghan-wu/hw1/index.html">https://cal-cs184-student.github.io/hw-webpages-tsunghan-wu/hw1/index.html</a>
		
		<br>

		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/hw1-rasterizer-tomay">https://github.com/cal-cs184-student/hw1-rasterizer-tomay</a>

<!-- 		<figure>
			<img src="lion.jpg" alt="Lion" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>
 -->
		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		This assignment asked us to write a simple rasterizer using C++. The first two tasks focused on basic triangle rasterization with superpixel anti-aliasing. The third task was implementing three simple 2D transformation matrices. Task 4 asked us to implement barycentric coordinates, which I found tricky because we need to handle edge cases carefully; otherwise we can end up with white strips on the image. The final two tasks (Tasks 5–6) then asked us to implement texture mapping. Overall, through building these pieces end-to-end, I learned how the rasterization pipeline actually work (compared to  only reading slides), and how small implementation details (like sampling and edge handling) can noticeably affect the final rendered result.

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		In this task, we implemented a basic triangle rasterization routine. In <code>void RasterizerImp::rasterize_triangle</code>, we first compute the triangle’s bounding box (a rectangle that covers the triangle). Then, for each point inside that region, we perform the three-line inside-triangle test (ref: Lecture 2 slides). We structured this logic using two helper functions: <code>is_inside_check</code> and <code>check_line</code>.

		One important detail is the homework requirement that points on the triangle edges should be treated as inside the triangle. To handle this, we used the following condition:
		<pre><code>if (line0_dot &gt;= 0 &amp;&amp; line1_dot &gt;= 0 &amp;&amp; line2_dot &gt;= 0) {
  return 1;
}</code></pre>

		That’s essentially it for this task. We did not implement the extra-credit optimizations, so the algorithm simply iterates over all points in the bounding box and checks whether each one is inside the triangle.

		The two requested PNG files are shown below. We can see that <code>basic/test.svg</code> renders successfully (a), but when zooming in, artifacts are visible because we are not yet using superpixels for anti-aliasing (b). We address this issue in the next task.

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="pics/task1_a.png" width="400px"/>
				  <figcaption>(a) Screenshot of Test4.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="pics/task1_b.png" width="400px"/>
				  <figcaption>(b) Screenshot of Zoomed-In Test4.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		We then implemented supersampling to mitigate the artifact we mentioned above. There are two main parts we need to modify in the code: (1) We need to make the buffer size from <code>H*W</code> to <code>H*W*sample_rate</code>; the modifications include the constructor (RasterizerImp), fill_pixel, set_sample_rate, set_framebuffer_target. (2) Then, the main function for supersampling is inside the <code>rasterize_triangle</code> function without a lot of tricks: it's just another for loop going through all grids inside a single pixel, and then in <code>resolve_to_framebuffer</code>, we average the value over all grids inside a single pixel so we will show blurred results there. The results of four different sample rates on the triangle is shown below. It's obvious that supersampling does mitigate the sharp boundary artifact.
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="pics/task2_sr1.png" width="400px"/>
				  <figcaption>(a) Sample Rate = 1.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="pics/task2_sr4.png" width="400px"/>
				  <figcaption>(b) Sample Rate = 4.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="pics/task2_sr9.png" width="400px"/>
				  <figcaption>(c) Sample Rate = 9.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="pics/task2_sr16.png" width="400px"/>
				  <figcaption>(d) Sample Rate = 16.</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>Task 3: Transforms</h2>
		In this task, we implemented the homogeneous 3x3 matrices for translation, rotation, and scaling, following the formulas we learned in Lecture 4. With these transforms in place, we can successfully render <code>robot.svg</code>. After that, I played with the SVG by adding a skateboard (with two wheels) using extra polygons, and then applying additional rotate/translate transforms to the arms and legs so the robot can stay balanced on the skateboard. The default robot (a) and my updated robot (b, SVG file in the <code>docs/</code> directory) are shown below:

		<div style="display: flex; flex-direction: column; align-items: center;">
		  <table style="width: 100%; text-align: center; border-collapse: collapse;">
		    <tr>
		      <td style="text-align: center;">
		        <img src="pics/task3_a.png" width="400px"/>
		        <figcaption>(a) The Default Robot.</figcaption>
		      </td>
		      <td style="text-align: center;">
		        <img src="pics/task3_b.png" width="400px"/>
		        <figcaption>(b) My Updated Robot (Raw SVG files in GitHub).</figcaption>
		      </td>
		    </tr>
		  </table>
		</div>

		<h2>Task 4: Barycentric coordinates</h2>
		To implement this task, I reused the same structure as triangle rasterization: compute a bounding box for the triangle, iterate over pixels (and sub-pixel samples when supersampling is enabled), and then determine whether each point lies inside the triangle or not. For samples that are inside, I compute barycentric weights using an area/edge-function form (solving for <code>&alpha;</code> and <code>&beta;</code>, then <code>&gamma; = 1 - &alpha; - &beta;</code>). The detailed formula is in the lecture slide. Finally, I interpolate the color by weighting the three vertex colors. It is worth mentioning that I added a small <code>eps</code> term in the barycentric denominators to reduce numerical instability near edges (e.g., when the denominator is extremely small due to floating point precision). This helps make the interpolation more stable at boundaries. Below is the requested screenshot of <code>svg/basic/test7.svg</code> with default viewing parameters and <code>sample_rate = 1</code>.


		<figure>
			<img src="pics/task4.png" alt="Lion" style="width:50%"/>
			<figcaption>Task 4's Color Palette</figcaption>
		</figure>


		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

<!-- 		<h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. -->

		<!-- <h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul> -->
		</div>
	</body>
</html>